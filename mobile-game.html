<!doctype html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
    <title>Homie ‚Äî Mobile game</title>
    <style>
      :root {
        --bg: #0b0f17;
        --panel: rgba(255, 255, 255, 0.06);
        --border: rgba(255, 255, 255, 0.14);
        --text: #e7eefc;
        --muted: #aab7d6;
        --accent: #7dd3fc;
        --danger: #fb7185;
        --good: #34d399;
      }
      * {
        box-sizing: border-box;
        touch-action: none;
      }
      html,
      body {
        overscroll-behavior: none;
        overscroll-behavior-x: none;
        overscroll-behavior-y: none;
        overflow: hidden;
      }
      body {
        margin: 0;
        background: radial-gradient(900px 600px at 30% 0%, #132036 0%, var(--bg) 60%);
        color: var(--text);
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Segoe UI Emoji",
          "Apple Color Emoji", "Noto Color Emoji", sans-serif;
        height: 100vh;
      }
      .wrap {
        max-width: 900px;
        margin: 0 auto;
        padding: 10px;
        padding-bottom: calc(10px + env(safe-area-inset-bottom));
        height: 100vh;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .title {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 10px;
      }
      .title h1 {
        margin: 0;
        font-size: 16px;
        font-weight: 800;
        letter-spacing: 0.2px;
      }
      .title .sub {
        color: var(--muted);
        font-size: 12px;
        font-variant-numeric: tabular-nums;
      }
      .panel {
        border: 1px solid var(--border);
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.04), rgba(255, 255, 255, 0.02));
        border-radius: 14px;
        padding: 10px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
        flex: 1;
        min-height: 0;
        display: flex;
        flex-direction: column;
        gap: 10px;
        overflow: hidden;
      }
      .big {
        flex: 1;
        min-height: 0;
        display: flex;
        align-items: flex-start;
        justify-content: center;
      }
      .mini-row {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 5px;
        align-items: stretch;
      }
      .mini {
        display: grid;
        gap: 0px;
        width: 100%;
        position: relative;
      }
      canvas {
        display: block;
        width: 100%;
        height: 100%;
        aspect-ratio: 1 / 1;
        border-radius: 14px;
        border: 1px solid var(--border);
        background: rgba(0, 0, 0, 0.16);
        image-rendering: pixelated;
      }

      .winner-overlay {
        position: absolute;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        background: rgba(34, 197, 94, 0.92);
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        overflow: hidden;
      }
      .winner-overlay.show {
        display: grid;
        place-items: center;
      }
      .winner-overlay .trophy {
        text-align: center;
        font-size: clamp(44px, 14vw, 96px);
        line-height: 1;
        filter: drop-shadow(0 6px 10px rgba(0, 0, 0, 0.35));
      }

      /* balloon temporarily disabled */
      .balloon-layer {
        display: none;
      }

      .emoji-grid {
        --cell: 22px;
        --cell-font: 18px;
        display: grid;
        gap: 1px;
        width: 100%;
        justify-content: center;
        align-content: start;
        border-radius: 14px;
        border: none;
        background: transparent;
        padding: 6px;
        flex: 1;
        min-height: 0;
        overflow: hidden;
        -webkit-overflow-scrolling: touch;
      }
      .cell {
        width: var(--cell);
        height: var(--cell);
        display: grid;
        place-items: center;
        font-size: var(--cell-font);
        line-height: 1;
        user-select: none;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Segoe UI Emoji",
          "Apple Color Emoji", "Noto Color Emoji", sans-serif;
      }
      .overlay {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        padding: 16px;
        background: rgba(0, 0, 0, 0.6);
      }
      .overlay.show {
        display: flex;
      }
      .modal {
        width: min(520px, 100%);
        border-radius: 16px;
        border: 1px solid var(--border);
        background: #0f1622;
        padding: 14px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.55);
      }
      .modal .big-emoji {
        width: 100%;
        text-align: center;
        font-size: min(42vh, 220px);
        line-height: 1;
        margin: 6px 0 10px;
        filter: drop-shadow(0 18px 28px rgba(0, 0, 0, 0.55));
      }
      .modal h2 {
        margin: 0 0 8px;
        font-size: 16px;
        font-weight: 900;
      }
      .modal p {
        margin: 0 0 12px;
        color: var(--muted);
        font-size: 13px;
        line-height: 1.35;
      }
      .modal .row {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
      }
      .pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.04);
        color: var(--muted);
        font-size: 12px;
        font-variant-numeric: tabular-nums;
        margin-left: 10px;
      }

      .sound-btn {
        position: fixed;
        right: 10px;
        bottom: calc(10px + env(safe-area-inset-bottom));
        z-index: 10000;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        background: rgba(17, 24, 39, 0.72);
        color: var(--text);
        width: 44px;
        height: 44px;
        display: grid;
        place-items: center;
        font-size: 18px;
        line-height: 1;
        cursor: pointer;
        user-select: none;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="title">
        <h1>Homie ‚Äî –∏–≥—Ä–∞ (mobile)</h1>
        <div class="sub" id="hud">‚Äî</div>
      </div>

      <div class="panel">
        <div class="mini-row">
          <div class="mini">
            <canvas id="mini1"></canvas>
            <div class="winner-overlay" id="win1"><div class="trophy" id="trophy1">üèÜ</div></div>
          </div>
          <div class="mini">
            <canvas id="mini2"></canvas>
            <div class="winner-overlay" id="win2"><div class="trophy" id="trophy2">üèÜ</div></div>
          </div>
          <div class="mini">
            <canvas id="mini3"></canvas>
            <div class="winner-overlay" id="win3"><div class="trophy" id="trophy3">üèÜ</div></div>
          </div>
        </div>

        <div class="big">
          <div id="bigGrid" class="emoji-grid" aria-label="–ò–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ"></div>
        </div>
      </div>
    </div>

    <div class="balloon-layer" id="balloonLayer"></div>

    <audio id="bgAudio" src="chipi.mp3" preload="auto" loop></audio>
    <button id="soundBtn" class="sound-btn" aria-label="–ó–≤—É–∫">üîá</button>

    <div class="overlay" id="overlay">
      <div class="modal">
        <h2 id="modalTitle">‚Äî</h2>
        <div class="big-emoji" id="modalEmoji" aria-hidden="true">üí∞</div>
        <p id="modalText">‚Äî</p>
        <div class="row">
          <button id="modalClose" class="primary">–û–∫</button>
        </div>
      </div>
    </div>

    <script>
      // ---------- utils ----------
      function clampInt(v, min, max) {
        const n = Number.parseInt(String(v), 10);
        if (Number.isNaN(n)) return min;
        return Math.max(min, Math.min(max, n));
      }
      function mulberry32(seed) {
        let t = seed >>> 0;
        return function () {
          t += 0x6d2b79f5;
          let x = Math.imul(t ^ (t >>> 15), 1 | t);
          x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
          return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
        };
      }
      function hashStringToSeed(s) {
        let h = 2166136261;
        for (let i = 0; i < s.length; i++) {
          h ^= s.charCodeAt(i);
          h = Math.imul(h, 16777619);
        }
        return h >>> 0;
      }
      function pick(rng, arr) {
        return arr[Math.floor(rng() * arr.length)];
      }
      function inBounds(x, y, N) {
        return Math.abs(x) <= N && Math.abs(y) <= N;
      }
      function idx(x, N) {
        return x + N;
      }
      function keyOf(x, y) {
        return x + "," + y;
      }

      const DIRS8 = [
        { dx: 1, dy: 0, name: "‚Üí" },
        { dx: -1, dy: 0, name: "‚Üê" },
        { dx: 0, dy: 1, name: "‚Üë" },
        { dx: 0, dy: -1, name: "‚Üì" },
        { dx: 1, dy: 1, name: "‚Üó" },
        { dx: -1, dy: 1, name: "‚Üñ" },
        { dx: 1, dy: -1, name: "‚Üò" },
        { dx: -1, dy: -1, name: "‚Üô" }
      ];

      function makeGrid(size, fill) {
        const a = new Array(size);
        for (let i = 0; i < size; i++) a[i] = new Array(size).fill(fill);
        return a;
      }

      // ---------- Scenario base (same as in index.html, but minimal) ----------
      class ScenarioBase {
        constructor({ N, V, rng, princess }) {
          this.N = N;
          this.V = V;
          this.rng = rng;
          this.princess = princess; // [x,y]
          this.size = 2 * N + 1;

          this.dug = makeGrid(this.size, false); // [y][x]
          this.dug[idx(0, N)][idx(0, N)] = true;

          this.ham = { x: 0, y: 0 };
          this.time = 0;
          this.found = false;
          this.iter = 0;

          if (this.isPrincess(0, 0)) {
            this.found = true;
          }
        }
        isPrincess(x, y) {
          return x === this.princess[0] && y === this.princess[1];
        }
        markDug(x, y) {
          this.dug[idx(y, this.N)][idx(x, this.N)] = true;
        }
        isDug(x, y) {
          return this.dug[idx(y, this.N)][idx(x, this.N)];
        }
        addTimeDig(steps = 1) {
          this.time += steps * (1 / this.V);
        }
        addTimeWalk(steps = 1) {
          this.time += steps * (1 / (10 * this.V));
        }
        step() {
          throw new Error("Not implemented");
        }
      }

      class Scenario1 extends ScenarioBase {
        constructor(opts) {
          super(opts);
          this.anchor = { x: 0, y: 0 };
          this.boundaryAnchors = [{ x: 0, y: 0 }];
          this.usedByAnchor = new Map();
          this.phase = "choose"; // choose | dig | back | backShort
          this.dir = null;
          this.path = [];
          this.backStepsRemaining = 0;
        }
        pickAnchorIfNeeded() {
          const aKey = keyOf(this.anchor.x, this.anchor.y);
          const used = this.usedByAnchor.get(aKey) || new Set();
          if (used.size < DIRS8.length) return;
          const chosen = pick(this.rng, this.boundaryAnchors);
          this.anchor = { x: chosen.x, y: chosen.y };
        }
        chooseDirection() {
          this.pickAnchorIfNeeded();
          const aKey = keyOf(this.anchor.x, this.anchor.y);
          let used = this.usedByAnchor.get(aKey);
          if (!used) {
            used = new Set();
            this.usedByAnchor.set(aKey, used);
          }
          let available = DIRS8.filter((d) => !used.has(d.name));
          if (!available.length) {
            used.clear();
            available = DIRS8;
          }
          const d = pick(this.rng, available);
          used.add(d.name);
          return d;
        }
        stepOneMove() {
          if (this.found) return false;

          if (this.phase === "choose") {
            this.ham.x = this.anchor.x;
            this.ham.y = this.anchor.y;
            this.dir = this.chooseDirection();
            this.path = [];
            this.phase = "dig";
            return true;
          }

          if (this.phase === "dig") {
            const nx = this.ham.x + this.dir.dx;
            const ny = this.ham.y + this.dir.dy;
            if (!inBounds(nx, ny, this.N)) {
              this.boundaryAnchors.push({ x: this.ham.x, y: this.ham.y });
              const desired = 1 + Math.floor(this.rng() * 2);
              this.backStepsRemaining = Math.min(desired, this.path.length);
              if (this.backStepsRemaining > 0) this.phase = "backShort";
              else this.phase = "back";
              return true;
            }
            this.path.push({ x: this.ham.x, y: this.ham.y });
            this.ham.x = nx;
            this.ham.y = ny;
            if (!this.isDug(nx, ny)) {
              this.markDug(nx, ny);
              this.addTimeDig(1);
            } else {
              this.addTimeWalk(1);
            }
            this.iter++;
            if (this.isPrincess(nx, ny)) this.found = true;
            return true;
          }

          if (this.phase === "backShort") {
            if (this.backStepsRemaining <= 0) {
              this.anchor = { x: this.ham.x, y: this.ham.y };
              this.phase = "choose";
              return true;
            }
            const prev = this.path.pop();
            if (!prev) {
              this.backStepsRemaining = 0;
              this.anchor = { x: this.ham.x, y: this.ham.y };
              this.phase = "choose";
              return true;
            }
            this.ham.x = prev.x;
            this.ham.y = prev.y;
            this.addTimeWalk(1);
            this.iter++;
            this.backStepsRemaining--;
            if (this.isPrincess(this.ham.x, this.ham.y)) this.found = true;
            return true;
          }

          if (this.phase === "back") {
            if (this.ham.x === this.anchor.x && this.ham.y === this.anchor.y) {
              this.phase = "choose";
              return true;
            }
            const prev = this.path.pop();
            if (!prev) {
              this.ham.x = this.anchor.x;
              this.ham.y = this.anchor.y;
              this.phase = "choose";
              return true;
            }
            this.ham.x = prev.x;
            this.ham.y = prev.y;
            this.addTimeWalk(1);
            this.iter++;
            if (this.isPrincess(this.ham.x, this.ham.y)) this.found = true;
            return true;
          }

          return false;
        }
        step({ digMovesPerTick, walkMovesPerTick }) {
          if (this.found) return;
          const isWalk = this.phase === "back" || this.phase === "backShort";
          const moves = isWalk ? walkMovesPerTick : digMovesPerTick;
          for (let i = 0; i < moves; i++) {
            if (!this.stepOneMove()) break;
            if (this.found) break;
          }
        }
      }

      class Scenario2 extends ScenarioBase {
        constructor(opts) {
          super(opts);
          this.origin = { x: 0, y: 0 };
          this.phase = "choose"; // choose | out | back
          this.dir = null;
          this.path = [];
          this.remaining = 0;
          this.L = Math.max(1, Math.round(Math.log2(this.N)));
        }
        stepOneMove() {
          if (this.found) return false;

          if (this.phase === "choose") {
            this.ham.x = this.origin.x;
            this.ham.y = this.origin.y;
            this.dir = pick(this.rng, DIRS8);
            this.remaining = this.L;
            this.path = [];
            this.phase = "out";
            return true;
          }

          if (this.phase === "out") {
            if (this.remaining <= 0) {
              this.phase = "back";
              return true;
            }
            const nx = this.ham.x + this.dir.dx;
            const ny = this.ham.y + this.dir.dy;
            if (!inBounds(nx, ny, this.N)) {
              this.phase = "back";
              return true;
            }

            this.path.push({ x: this.ham.x, y: this.ham.y });
            this.ham.x = nx;
            this.ham.y = ny;

            if (!this.isDug(nx, ny)) {
              this.markDug(nx, ny);
              this.addTimeDig(1);
              this.remaining--;
            } else {
              this.addTimeWalk(1);
              const next2x = nx + this.dir.dx;
              const next2y = ny + this.dir.dy;
              if (!inBounds(next2x, next2y, this.N) || !this.isDug(next2x, next2y)) {
                this.origin = { x: this.ham.x, y: this.ham.y };
                this.phase = "choose";
              }
            }
            this.iter++;
            if (this.isPrincess(nx, ny)) this.found = true;
            return true;
          }

          if (this.phase === "back") {
            if (this.ham.x === this.origin.x && this.ham.y === this.origin.y) {
              this.phase = "choose";
              return true;
            }
            const prev = this.path.pop();
            if (!prev) {
              this.ham.x = this.origin.x;
              this.ham.y = this.origin.y;
              this.phase = "choose";
              return true;
            }
            this.ham.x = prev.x;
            this.ham.y = prev.y;
            this.addTimeWalk(1);
            this.iter++;
            if (this.isPrincess(this.ham.x, this.ham.y)) this.found = true;
            return true;
          }

          return false;
        }
        step({ digMovesPerTick, walkMovesPerTick }) {
          if (this.found) return;
          const isWalk = this.phase === "back";
          const moves = isWalk ? walkMovesPerTick : digMovesPerTick;
          for (let i = 0; i < moves; i++) {
            if (!this.stepOneMove()) break;
            if (this.found) break;
          }
        }
      }

      // Scenario3: simplified (3 branches, switching cost ignored for game fairness; still uses time)
      // For game we keep same behavior as main sim: 3 branches + switching + restarts each 30 iters
      function shortestTunnelPath(dug, N, from, to) {
        const size = 2 * N + 1;
        const [sx, sy] = from;
        const [tx, ty] = to;
        if (sx === tx && sy === ty) return [[sx, sy]];
        const q = [];
        const visited = new Array(size * size).fill(false);
        const prev = new Array(size * size).fill(-1);
        const sIdx = idx(sx, N) + idx(sy, N) * size;
        const tIdx = idx(tx, N) + idx(ty, N) * size;
        q.push([sx, sy]);
        visited[sIdx] = true;
        while (q.length) {
          const [x, y] = q.shift();
          for (const d of DIRS8) {
            const nx = x + d.dx;
            const ny = y + d.dy;
            if (!inBounds(nx, ny, N)) continue;
            const xi = idx(nx, N);
            const yi = idx(ny, N);
            const flat = xi + yi * size;
            if (visited[flat]) continue;
            if (!dug[yi][xi]) continue;
            visited[flat] = true;
            prev[flat] = idx(x, N) + idx(y, N) * size;
            if (flat === tIdx) {
              const path = [];
              let cur = flat;
              while (cur !== -1) {
                const cx = (cur % size) - N;
                const cy = Math.floor(cur / size) - N;
                path.push([cx, cy]);
                if (cur === sIdx) break;
                cur = prev[cur];
              }
              path.reverse();
              return path;
            }
            q.push([nx, ny]);
          }
        }
        return null;
      }

      class Scenario3 extends ScenarioBase {
        constructor(opts) {
          super(opts);
          this.branches = [];
          this.active = 0;
          this.switchPath = null;
          this.restartEvery = 30;
          this.initBranchesAt([0, 0]);
        }
        initBranchesAt([x, y]) {
          const dirs = [...DIRS8];
          const chosen = [];
          for (let i = 0; i < 3; i++) {
            const d = pick(this.rng, dirs.splice(Math.floor(this.rng() * dirs.length), 1));
            chosen.push(d);
          }
          this.branches = chosen.map((d) => ({ x, y, dx: d.dx, dy: d.dy, name: d.name }));
          this.active = 0;
        }
        randomDugCell() {
          const cells = [];
          for (let y = -this.N; y <= this.N; y++) {
            for (let x = -this.N; x <= this.N; x++) {
              if (this.isDug(x, y)) cells.push([x, y]);
            }
          }
          return pick(this.rng, cells);
        }
        ensureSwitchPath(targetX, targetY) {
          if (this.ham.x === targetX && this.ham.y === targetY) {
            this.switchPath = null;
            return;
          }
          const path = shortestTunnelPath(this.dug, this.N, [this.ham.x, this.ham.y], [targetX, targetY]);
          this.switchPath = path ? path.slice(1) : null;
          if (!this.switchPath) {
            this.ham.x = targetX;
            this.ham.y = targetY;
          }
        }
        stepOneMove() {
          if (this.found) return false;
          if (this.iter > 0 && this.iter % this.restartEvery === 0) {
            const origin = this.randomDugCell();
            this.initBranchesAt(origin);
            this.switchPath = null;
          }
          const b = this.branches[this.active];
          if (!this.switchPath) this.ensureSwitchPath(b.x, b.y);
          if (this.switchPath && this.switchPath.length) {
            const [nx, ny] = this.switchPath.shift();
            this.ham.x = nx;
            this.ham.y = ny;
            this.addTimeWalk(1);
            this.iter++;
            return true;
          }
          let nx = b.x + b.dx;
          let ny = b.y + b.dy;
          if (!inBounds(nx, ny, this.N)) {
            const shuffled = [...DIRS8].sort(() => this.rng() - 0.5);
            let chosen = null;
            for (const d of shuffled) {
              const tx = b.x + d.dx;
              const ty = b.y + d.dy;
              if (inBounds(tx, ty, this.N)) {
                chosen = d;
                break;
              }
            }
            if (chosen) {
              b.dx = chosen.dx;
              b.dy = chosen.dy;
              b.name = chosen.name;
            }
            this.active = (this.active + 1) % 3;
            return true;
          }
          b.x = nx;
          b.y = ny;
          this.ham.x = nx;
          this.ham.y = ny;
          if (!this.isDug(nx, ny)) {
            this.markDug(nx, ny);
            this.addTimeDig(1);
          } else {
            this.addTimeWalk(1);
          }
          this.iter++;
          if (this.isPrincess(nx, ny)) this.found = true;
          this.active = (this.active + 1) % 3;
          this.switchPath = null;
          return true;
        }
        step({ digMovesPerTick, walkMovesPerTick }) {
          if (this.found) return;
          const budget = digMovesPerTick + walkMovesPerTick;
          for (let i = 0; i < budget; i++) {
            if (!this.stepOneMove()) break;
            if (this.found) break;
          }
        }
      }

      // ---------- rendering ----------
      function setupCanvas(canvas, pixels) {
        // pixels = logical grid size (2N+1). We keep the backing store exactly pixels√ópixels,
        // and scale via CSS (image-rendering: pixelated) for crisp "pixel" look.
        canvas.width = pixels;
        canvas.height = pixels;
        const ctx = canvas.getContext("2d");
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.imageSmoothingEnabled = false;
        return ctx;
      }

      function drawMap(ctx, N, dug, ham, princess, { showPrincess, colorHam }) {
        const size = 2 * N + 1;
        const w = size;
        const h = size;
        ctx.clearRect(0, 0, w, h);

        // Base grid (so mini-maps don't look "empty")
        ctx.fillStyle = "#0b1220";
        ctx.fillRect(0, 0, w, h);
        ctx.fillStyle = "#111c2f";
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            ctx.fillRect(x, y, 1, 1);
          }
        }

        // dug
        ctx.fillStyle = "#22c55e"; // green visited
        for (let y = -N; y <= N; y++) {
          for (let x = -N; x <= N; x++) {
            if (dug[idx(y, N)][idx(x, N)]) {
              const px = x + N;
              const py = (N - y); // invert Y for display
              ctx.fillRect(px, py, 1, 1);
            }
          }
        }

        if (showPrincess && princess) {
          ctx.fillStyle = "#fbbf24"; // yellow
          const px = princess[0] + N;
          const py = (N - princess[1]);
          ctx.fillRect(px, py, 1, 1);
        }

        // hamster
        ctx.fillStyle = colorHam;
        const hx = ham.x + N;
        const hy = (N - ham.y);
        ctx.fillRect(hx, hy, 1, 1);
      }

      // ---------- game ----------
      const els = {
        hud: document.getElementById("hud"),
        mini1: document.getElementById("mini1"),
        mini2: document.getElementById("mini2"),
        mini3: document.getElementById("mini3"),
        bigGrid: document.getElementById("bigGrid"),
        win1: document.getElementById("win1"),
        win2: document.getElementById("win2"),
        win3: document.getElementById("win3"),
        trophy1: document.getElementById("trophy1"),
        trophy2: document.getElementById("trophy2"),
        trophy3: document.getElementById("trophy3"),
        balloonLayer: document.getElementById("balloonLayer"),
        bgAudio: document.getElementById("bgAudio"),
        soundBtn: document.getElementById("soundBtn"),
        overlay: document.getElementById("overlay"),
        modalTitle: document.getElementById("modalTitle"),
        modalEmoji: document.getElementById("modalEmoji"),
        modalText: document.getElementById("modalText"),
        modalClose: document.getElementById("modalClose")
      };

      let running = false;
      let gameOver = false;
      let rng = null;
      const N_DEFAULT = 4;
      const V_DEFAULT = 1;
      let N = N_DEFAULT;
      let V = V_DEFAULT;
      let princess = null;
      let treasureEmoji = "üí∞";

      let s1 = null;
      let s2 = null;
      let s3 = null;

      const aiWins = { s1: false, s2: false, s3: false };
      let aiWinCount = 0;

      const player = {
        ham: { x: 0, y: 0 },
        dug: null,
        moves: 0
      };

      let ctxMini1, ctxMini2, ctxMini3, ctxBig;
      let bigCells = null; // flat array of span cells (row-major: y from top (N) to bottom (-N))
      let lastPlayerPos = null;

      let soundEnabled = false;
      let triedAutoPlay = false;

      // Reduce interference from in-app browser gestures (Telegram / iOS back/close).
      // Can't guarantee 100%, but this significantly helps.
      function lockGestures(enable) {
        const on = !!enable;
        document.documentElement.style.touchAction = on ? "none" : "";
        document.body.style.touchAction = on ? "none" : "";
      }

      function samplePrincess(N, rng) {
        const x = Math.floor(rng() * (2 * N + 1)) - N;
        const y = Math.floor(rng() * (2 * N + 1)) - N;
        return [x, y];
      }

      function resetState() {
        gameOver = false;
        player.ham = { x: 0, y: 0 };
        player.moves = 0;
        player.dug = makeGrid(2 * N + 1, false);
        player.dug[idx(0, N)][idx(0, N)] = true;
        s1 = new Scenario1({ N, V, rng, princess });
        s2 = new Scenario2({ N, V, rng, princess });
        s3 = new Scenario3({ N, V, rng, princess });
        lastPlayerPos = { x: 0, y: 0 };

        aiWins.s1 = false;
        aiWins.s2 = false;
        aiWins.s3 = false;
        aiWinCount = 0;
        els.win1.classList.remove("show");
        els.win2.classList.remove("show");
        els.win3.classList.remove("show");
      }

      function showModal(title, text, emoji) {
        els.modalTitle.textContent = title;
        els.modalText.textContent = text;
        if (emoji) els.modalEmoji.textContent = emoji;
        els.overlay.classList.add("show");
      }

      // modalClose handler is set near the end to restart the game

      function renderAll() {
        els.hud.textContent = `–•–æ–¥—ã: ${player.moves} ‚Ä¢ AI: ${aiWinCount}/2`;

        // mini maps: show everything (including princess)
        // Do NOT show princess on mini-maps (no spoilers)
        drawMap(ctxMini1, N, s1.dug, s1.ham, princess, { showPrincess: false, colorHam: "#60a5fa" });
        drawMap(ctxMini2, N, s2.dug, s2.ham, princess, { showPrincess: false, colorHam: "#a78bfa" });
        drawMap(ctxMini3, N, s3.dug, s3.ham, princess, { showPrincess: false, colorHam: "#fb7185" });

        // big map: emoji grid, hide princess
        renderBigEmoji();
      }

      function showBalloon(_text) {
        // disabled for now
      }

      function setWinnerOverlay(num) {
        const trophyEl = num === 1 ? els.trophy1 : num === 2 ? els.trophy2 : els.trophy3;
        const overlayEl = num === 1 ? els.win1 : num === 2 ? els.win2 : els.win3;
        trophyEl.textContent = "üèÜ";
        // Make the trophy "big" to visually cover the mini-map
        const w = overlayEl.clientWidth || 96;
        const h = overlayEl.clientHeight || 96;
        const s = Math.max(44, Math.floor(Math.min(w, h) * 0.82));
        trophyEl.style.fontSize = `${s}px`;
        overlayEl.classList.add("show");
      }

      function registerAiWin(which) {
        if (aiWins[which]) return;
        aiWins[which] = true;
        aiWinCount++;
        const num = which === "s1" ? 1 : which === "s2" ? 2 : 3;
        setWinnerOverlay(num);
      }

      function bigIndexFromXY(x, y) {
        // our DOM is rendered with y from N..-N (top to bottom), and x from -N..N (left to right)
        const row = (N - y); // y=N => 0
        const col = (x + N);
        return row * (2 * N + 1) + col;
      }

      function setBigCell(x, y, emoji) {
        if (!bigCells) return;
        const i = bigIndexFromXY(x, y);
        const el = bigCells[i];
        if (el) el.textContent = emoji;
      }

      function buildBigEmojiGrid() {
        const size = 2 * N + 1;

        // Cell size based on actual available width+height of the container (so it fits without overflow).
        // We do a 2-pass: set columns first, then compute using real client sizes.
        els.bigGrid.style.gridTemplateColumns = `repeat(${size}, var(--cell))`;

        // Layout has to settle (fonts, safe areas), so compute on next frame.
        requestAnimationFrame(() => {
          const cs = getComputedStyle(els.bigGrid);
          const padX = (parseFloat(cs.paddingLeft) || 0) + (parseFloat(cs.paddingRight) || 0);
          const padY = (parseFloat(cs.paddingTop) || 0) + (parseFloat(cs.paddingBottom) || 0);
          const gap = parseFloat(cs.gap) || 0;
          const parent = els.bigGrid.parentElement; // .big
          const w = parent ? parent.clientWidth : els.bigGrid.clientWidth;
          const h = parent ? parent.clientHeight : els.bigGrid.clientHeight;
          const maxCellW = Math.floor((w - padX - gap * (size - 1)) / size);
          const maxCellH = Math.floor((h - padY - gap * (size - 1)) / size);
          const cell = Math.max(10, Math.min(26, Math.min(maxCellW, maxCellH)));
          const font = Math.max(10, Math.min(22, cell - 4));
          els.bigGrid.style.setProperty("--cell", `${cell}px`);
          els.bigGrid.style.setProperty("--cell-font", `${font}px`);
        });

        els.bigGrid.replaceChildren();
        const frag = document.createDocumentFragment();
        bigCells = new Array(size * size);

        for (let y = N; y >= -N; y--) {
          for (let x = -N; x <= N; x++) {
            const span = document.createElement("span");
            span.className = "cell";
            span.textContent = "‚¨ú";
            bigCells[bigIndexFromXY(x, y)] = span;
            frag.appendChild(span);
          }
        }
        els.bigGrid.appendChild(frag);
        // Initial paint
        renderBigEmoji(true);
      }

      function renderBigEmoji(full = false) {
        if (!bigCells) return;
        const size = 2 * N + 1;
        if (full) {
          for (let y = -N; y <= N; y++) {
            for (let x = -N; x <= N; x++) {
              const isVisited = player.dug[idx(y, N)][idx(x, N)];
              setBigCell(x, y, isVisited ? "üü©" : "‚¨ú");
            }
          }
        }

        // update previous hamster cell (unless it's visited, then keep üü©)
        if (lastPlayerPos) {
          const wasVisited = player.dug[idx(lastPlayerPos.y, N)][idx(lastPlayerPos.x, N)];
          setBigCell(lastPlayerPos.x, lastPlayerPos.y, wasVisited ? "üü©" : "‚¨ú");
        }

        // current hamster cell
        setBigCell(player.ham.x, player.ham.y, gameOver && !running ? "üéâ" : "üêπ");
        lastPlayerPos = { x: player.ham.x, y: player.ham.y };
      }

      function endGame(winner) {
        gameOver = true;
        running = false;
        // leave a visible celebration marker on the player's position if player won
        if (winner === "player") {
          setBigCell(player.ham.x, player.ham.y, "üéâ");
        }
        if (winner === "player") {
          showModal("–í—ã –ø–æ–±–µ–¥–∏–ª–∏!", `–í—ã –Ω–∞—à–ª–∏ —Å–æ–∫—Ä–æ–≤–∏—â–µ –∑–∞ ${player.moves} —Ö–æ–¥–æ–≤.`, treasureEmoji);
        } else {
          showModal("–ü–æ—Ä–∞–∂–µ–Ω–∏–µ", `–î–≤–∞ —Ö–æ–º—è–∫–∞ –Ω–∞—à–ª–∏ —Å–æ–∫—Ä–æ–≤–∏—â–µ —Ä–∞–Ω—å—à–µ –≤–∞—Å.\n–í–∞—à–∏ —Ö–æ–¥—ã: ${player.moves}`, treasureEmoji);
        }
      }

      function playerStep(dx, dy) {
        if (!running || gameOver) return;
        if (dx === 0 && dy === 0) return;

        const nx = player.ham.x + dx;
        const ny = player.ham.y + dy;
        if (!inBounds(nx, ny, N)) return;

        const visitedBefore = player.dug[idx(ny, N)][idx(nx, N)];
        player.ham.x = nx;
        player.ham.y = ny;
        player.moves++;
        player.dug[idx(ny, N)][idx(nx, N)] = true;
        // paint visited cell and hamster
        setBigCell(nx, ny, "üêπ");

        // player wins first if stepped onto princess
        if (nx === princess[0] && ny === princess[1]) {
          renderAll();
          endGame("player");
          return;
        }

        // –ù–µ–±–æ–ª—å—à–æ–π –±—É—Å—Ç –∏–≥—Ä–æ–∫—É:
        // –µ—Å–ª–∏ –∏–≥—Ä–æ–∫ —Ö–æ–¥–∏—Ç –ø–æ —É–∂–µ –ø—Ä–æ–π–¥–µ–Ω–Ω–æ–º—É (visitedBefore=true), AI —ç—Ç–æ—Ç —Ö–æ–¥ –ø—Ä–æ–ø—É—Å–∫–∞—é—Ç.
        if (!visitedBefore) {
          const digMovesPerTick = V;
          const walkMovesPerTick = 10 * V;
          if (!s1.found) s1.step({ digMovesPerTick, walkMovesPerTick });
          if (!s2.found) s2.step({ digMovesPerTick, walkMovesPerTick });
          if (!s3.found) s3.step({ digMovesPerTick, walkMovesPerTick });
        }

        renderAll();

        // Register AI wins; their mini-map becomes fully green + üèÜ (no spoiler trails)
        if (s1.found) registerAiWin("s1");
        if (s2.found) registerAiWin("s2");
        if (s3.found) registerAiWin("s3");

        // Player –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω–æ –ø—Ä–æ–∏–≥—Ä—ã–≤–∞–µ—Ç —Ç–æ–ª—å–∫–æ –∫–æ–≥–¥–∞ 2 –∏–∑ 3 –Ω–∞—à–ª–∏
        if (aiWinCount >= 2) return endGame("ai");
      }

      // ---------- touch / drag control ----------
      const drag = {
        active: false,
        lastX: 0,
        lastY: 0
      };

      function dirFromDelta(dx, dy) {
        // choose 8-dir by angle; require some movement
        const adx = Math.abs(dx);
        const ady = Math.abs(dy);
        if (adx < 1e-6 && ady < 1e-6) return { dx: 0, dy: 0 };
        // Normalize by dominant axis; thresholds chosen for nice diagonals
        const isDiag = adx / (ady + 1e-6) < 1.5 && ady / (adx + 1e-6) < 1.5;
        const sx = dx > 0 ? 1 : -1;
        const sy = dy > 0 ? -1 : 1; // screen Y down => game Y up
        if (isDiag) return { dx: sx, dy: sy };
        if (adx > ady) return { dx: sx, dy: 0 };
        return { dx: 0, dy: sy };
      }

      function attachDrag(canvas) {
        const threshold = 18; // px
        canvas.addEventListener("pointerdown", (e) => {
          if (!running || gameOver) return;
          if (els.overlay.classList.contains("show")) return;
          tryStartMusic();
          drag.active = true;
          drag.lastX = e.clientX;
          drag.lastY = e.clientY;
          // capture on element where we started to keep getting move events
          try {
            canvas.setPointerCapture?.(e.pointerId);
          } catch (_) {}
        });
        canvas.addEventListener("pointermove", (e) => {
          if (!drag.active || !running || gameOver) return;
          if (els.overlay.classList.contains("show")) return;
          const dx = e.clientX - drag.lastX;
          const dy = e.clientY - drag.lastY;
          const dist = Math.hypot(dx, dy);
          if (dist < threshold) return;
          const d = dirFromDelta(dx, dy);
          if (d.dx === 0 && d.dy === 0) return;
          playerStep(d.dx, d.dy);
          // reset anchor so –º–æ–∂–Ω–æ –≤–µ—Å—Ç–∏ –ø–∞–ª–µ—Ü –Ω–µ –æ—Ç–ø—É—Å–∫–∞—è
          drag.lastX = e.clientX;
          drag.lastY = e.clientY;
        });
        const end = () => {
          drag.active = false;
        };
        canvas.addEventListener("pointerup", end);
        canvas.addEventListener("pointercancel", end);
      }

      // ---------- lifecycle ----------
      function start() {
        N = N_DEFAULT;
        V = V_DEFAULT;
        const seed = Date.now() >>> 0;
        rng = mulberry32(seed);

        princess = samplePrincess(N, rng);
        treasureEmoji = pick(rng, ["üí∞", "üç©", "üß∂", "ü¶∑"]);

        // mini-canvas contexts at logical pixel size = (2N+1)
        const pixels = 2 * N + 1;
        ctxMini1 = setupCanvas(els.mini1, pixels);
        ctxMini2 = setupCanvas(els.mini2, pixels);
        ctxMini3 = setupCanvas(els.mini3, pixels);

        resetState();
        buildBigEmojiGrid();
        running = true;

        renderAll();
      }

      // Gesture can start anywhere on screen
      attachDrag(document.documentElement);

      function restart() {
        els.overlay.classList.remove("show");
        start();
      }

      // Tap "–û–∫" => –Ω–æ–≤–∞—è –∏–≥—Ä–∞
      els.modalClose.addEventListener("click", restart);

      // Auto-start on open
      window.addEventListener("load", () => {
        start();
      });

      // Refit grid on orientation/resize
      window.addEventListener("resize", () => {
        if (!running && !gameOver) return;
        if (bigCells) buildBigEmojiGrid();
      });

      // Prevent page scroll / pull-to-close gestures while playing.
      // Note: must be passive:false to allow preventDefault().
      document.addEventListener(
        "touchmove",
        (e) => {
          if (!running || gameOver) return;
          if (els.overlay.classList.contains("show")) return;
          e.preventDefault();
        },
        { passive: false }
      );

      // Telegram WebApp: disable vertical swipe-to-close when available.
      try {
        const tg = window.Telegram?.WebApp;
        if (tg?.disableVerticalSwipes) tg.disableVerticalSwipes();
        if (tg?.expand) tg.expand();
      } catch (_) {}

      async function tryStartMusic() {
        if (triedAutoPlay) return;
        triedAutoPlay = true;
        if (!soundEnabled) return;
        try {
          await els.bgAudio.play();
        } catch (_) {
          // Autoplay blocked or file missing; ignore silently.
        }
      }

      function updateSoundIcon() {
        els.soundBtn.textContent = soundEnabled ? "üîä" : "üîá";
      }

      els.soundBtn.addEventListener("click", async (e) => {
        e.stopPropagation();
        soundEnabled = !soundEnabled;
        updateSoundIcon();
        triedAutoPlay = false; // allow retry after explicit gesture
        if (!soundEnabled) {
          try {
            els.bgAudio.pause();
          } catch (_) {}
          return;
        }
        tryStartMusic();
      });

      updateSoundIcon();

      // Enable gesture lock by default (this page is a game; no scrolling UI).
      lockGestures(true);
    </script>
  </body>
</html>

